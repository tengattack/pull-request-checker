package vulnerability

import (
	"path/filepath"

	vulcommon "github.com/tengattack/unified-ci/checks/vulnerability/common"
	"github.com/tengattack/unified-ci/checks/vulnerability/riki"
	"github.com/tengattack/unified-ci/common"
	"github.com/tengattack/unified-ci/config"
	"github.com/tengattack/unified-ci/util"
)

// VulScanner interface
type VulScanner interface {
	CheckPackages(lang vulcommon.Language, pkgFilePath string) (bool, error)
	Query(lang vulcommon.Language) ([]vulcommon.Data, error)
	WaitForQuery()

	// context
	SetCommitID(commitID string)
	SetContext(context string)
}

// NewScanner creates new vulnerability scanner
func NewScanner(appName string, conf config.SectionVulnerability) VulScanner {
	return &riki.Scanner{
		AppName: conf.AppNamePrefix + appName,
		AppFrom: conf.AppFrom,
	}
}

// CheckVulnerability checks the package vulnerability of repo
func CheckVulnerability(projectName, repoPath, commitID, context string) (result []vulcommon.Data, err error) {
	var lang []vulcommon.Language
	scanner := NewScanner(projectName, common.Conf.Vulnerability)
	scanner.SetCommitID(commitID)
	scanner.SetContext(context)

	gomod := filepath.Join(repoPath, "go.sum")
	if util.FileExists(gomod) {
		_, err := scanner.CheckPackages(vulcommon.Golang, gomod)
		if err != nil {
			return nil, err
		}
		lang = append(lang, vulcommon.Golang)
	}
	composer := filepath.Join(repoPath, "composer.lock")
	if util.FileExists(composer) {
		_, err := scanner.CheckPackages(vulcommon.PHP, composer)
		if err != nil {
			return nil, err
		}
		lang = append(lang, vulcommon.PHP)
	}
	nodePackage := filepath.Join(repoPath, "package.json")
	if util.FileExists(nodePackage) {
		_, err := scanner.CheckPackages(vulcommon.NodeJS, nodePackage)
		if err != nil {
			return nil, err
		}
		lang = append(lang, vulcommon.NodeJS)
	}

	if len(lang) > 0 {
		scanner.WaitForQuery()
		for _, v := range lang {
			data, err := scanner.Query(v)
			if err != nil {
				return nil, err
			}
			result = append(result, data...)
		}
	}
	return result, nil
}
